# Story 1.4: Refactor ContextManager for Extensibility

## Status
Draft

## Story
**As a** developer,  
**I want** the ContextManager refactored,  
**so that** its state-loading and saving logic can be easily extended to support profiles without modifying its core responsibilities.

## Acceptance Criteria
1. The logic for reading from and writing to `state.json` is decoupled from the in-memory context management.
2. The refactored ContextManager maintains all existing functionality.
3. Unit tests are written for the ContextManager's core state manipulation methods (e.g., `add_files`, `remove_files`).
4. The class and its methods are documented to reflect the new internal structure.

## Tasks / Subtasks
- [ ] Create storage abstraction layer (AC: 1)
  - [ ] Create storage/base.py with StorageBackend abstract class
  - [ ] Create storage/json_storage.py implementing JsonStorage
  - [ ] Define clear interface for save/load operations
- [ ] Refactor ContextManager to use storage abstraction (AC: 1, 2)
  - [ ] Extract state I/O logic from ContextManager
  - [ ] Inject storage backend via constructor
  - [ ] Update all state persistence calls to use storage
  - [ ] Ensure backward compatibility with existing state.json
- [ ] Maintain existing functionality (AC: 2)
  - [ ] Verify all CLI commands work unchanged
  - [ ] Ensure state.json format remains the same
  - [ ] Test file discovery and filtering still works
  - [ ] Confirm no breaking changes to public API
- [ ] Write comprehensive unit tests (AC: 3)
  - [ ] Test add_files with various patterns
  - [ ] Test remove_files functionality
  - [ ] Test get_files with filtering
  - [ ] Test state persistence and loading
  - [ ] Test error handling scenarios
  - [ ] Mock storage backend for unit tests
- [ ] Update documentation (AC: 4)
  - [ ] Add docstrings to all public methods
  - [ ] Document the new architecture in comments
  - [ ] Update any existing documentation
  - [ ] Create architecture diagram if helpful

## Dev Notes

### Current ContextManager Structure
```python
class ContextManager:
    def __init__(self):
        self.watched_patterns = set()
        self.ignore_patterns = set()
        self.files = set()
        self._load_state()
    
    def _load_state(self):
        # Loads from .contextr/state.json
    
    def save_state(self):
        # Saves to .contextr/state.json
```

### Proposed Storage Abstraction
```python
from abc import ABC, abstractmethod
from typing import Dict, Optional

class StorageBackend(ABC):
    @abstractmethod
    def save(self, key: str, data: Dict) -> None:
        """Save data with given key"""
        
    @abstractmethod
    def load(self, key: str) -> Optional[Dict]:
        """Load data by key"""

class JsonStorage(StorageBackend):
    def __init__(self, base_path: Path):
        self.base_path = base_path
```

### Refactored ContextManager Structure
```python
class ContextManager:
    def __init__(self, storage: Optional[StorageBackend] = None):
        self.storage = storage or JsonStorage(Path(".contextr"))
        self.watched_patterns = set()
        self.ignore_patterns = set()
        self.files = set()
        self._load_state()
```

### Key Considerations
- Storage backend should be injectable for testing
- Default to current JSON storage for backward compatibility
- Keep the same state.json structure
- Storage abstraction prepares for future profile support
- All existing functionality must continue working

### Testing Strategy
- Unit tests with mocked storage backend
- Integration tests with real file system
- Test backward compatibility explicitly
- Verify no performance regression

### Migration Path
1. Create storage abstraction
2. Refactor ContextManager incrementally
3. Ensure all tests pass at each step
4. No changes to CLI interface
5. State file format unchanged

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-07-23 | 1.0 | Initial story creation | BMad Master |

## Dev Agent Record
### Agent Model Used
(To be filled by dev agent)

### Debug Log References
(To be filled by dev agent)

### Completion Notes List
(To be filled by dev agent)

### File List
(To be filled by dev agent)

## QA Results
(To be filled by QA agent)