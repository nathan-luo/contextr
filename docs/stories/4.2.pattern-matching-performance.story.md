# Story 4.2: Implement Pattern Matching Performance Optimizations

## Status
Draft

## Story
**As a** developer using contextr on large codebases,
**I want** pattern matching to be 10x faster,
**so that** I don't accidentally process huge directories like node_modules or .venv

## Acceptance Criteria
1. Compiled regex patterns are cached to prevent recompilation
2. Directory-level ignore patterns terminate traversal early
3. Performance benchmarks show 10x improvement on directories with 10k+ files
4. All existing ignore pattern tests continue to pass
5. Memory usage remains reasonable under high file counts

## Tasks / Subtasks
- [ ] Task 1: Implement regex pattern caching (AC: 1, 4)
  - [ ] Add `_compiled_patterns` cache dict to IgnoreManager class
  - [ ] Modify `_compile_patterns()` to cache compiled regex objects
  - [ ] Update `add_pattern()` and `remove_pattern()` to manage cache
  - [ ] Ensure cache is cleared when patterns change
  - [ ] Add unit tests for caching behavior
- [ ] Task 2: Implement early directory termination (AC: 2, 4)
  - [ ] Modify `should_ignore()` to detect directory-level patterns
  - [ ] Update `manager.py` `_add_files()` to skip entire directory trees when parent is ignored
  - [ ] Add special handling for patterns ending with `/` or `/**`
  - [ ] Test with common patterns like `node_modules/`, `.git/`, `.venv/`
- [ ] Task 3: Optimize path operations (AC: 3, 5)
  - [ ] Cache `Path.resolve()` results to avoid repeated file system calls
  - [ ] Use os.path operations instead of Path where performance critical
  - [ ] Implement lazy evaluation for relative path calculations
  - [ ] Profile memory usage with large file sets
- [ ] Task 4: Add performance benchmarks (AC: 3)
  - [ ] Create benchmark test file `tests/benchmarks/test_pattern_performance.py`
  - [ ] Generate test directories with 1k, 10k, 100k files
  - [ ] Measure pattern matching time before and after optimizations
  - [ ] Assert 10x improvement on large directories
  - [ ] Add benchmark to CI as optional check

## Dev Notes

### Current Implementation Analysis
[Source: Investigation of src/contextr/utils/ignore_utils.py]

The current `IgnoreManager` implementation has several performance bottlenecks:

1. **Pattern Compilation** (lines 44-56):
   - `_compile_patterns()` is called on EVERY `add_pattern()` or `remove_pattern()`
   - ALL patterns are recompiled each time, not just new ones
   - No caching of compiled regex objects

2. **Path Resolution** (lines 112-114):
   - `should_ignore()` calls `Path.resolve()` for every file
   - Calculates relative paths repeatedly for the same files
   - No caching of resolved paths

3. **Directory Traversal** (src/contextr/manager.py:216-222):
   ```python
   for file_path in p.rglob("*"):
       if file_path.is_file():
           file_abs = str(file_path.resolve())
           if not self.ignore_manager.should_ignore(file_abs):
   ```
   - Traverses ALL files even in ignored directories
   - No early termination when parent directory is ignored

### Optimization Strategy

1. **Regex Caching Implementation**:
   ```python
   class IgnoreManager:
       def __init__(self):
           self._compiled_patterns: Dict[str, re.Pattern] = {}
           self._pattern_cache_valid = False
       
       def _get_compiled_pattern(self, pattern: str) -> re.Pattern:
           if pattern not in self._compiled_patterns:
               self._compiled_patterns[pattern] = self._compile_single_pattern(pattern)
           return self._compiled_patterns[pattern]
   ```

2. **Directory-Level Termination**:
   - Check if a directory itself matches ignore patterns before traversing
   - Special handling for patterns like `node_modules/`, `.git/`, `**/__pycache__/`
   - Skip entire subtree when parent is ignored

3. **Path Caching**:
   - Cache resolved absolute paths
   - Cache relative path calculations
   - Use `os.path.relpath()` instead of `Path.relative_to()` for performance

### Testing Standards
[Source: docs/architecture.md#testing-strategy]
- Performance tests go in `tests/benchmarks/` directory
- Use pytest-benchmark if needed for precise measurements
- Mock file system for reproducible benchmarks
- Test with realistic directory structures (node_modules-like)

### Memory Considerations
- Monitor cache sizes to prevent unbounded growth
- Implement LRU cache if needed for path resolutions
- Clear caches when patterns change significantly

### Common Large Directories to Test
- `node_modules/` - Often 50k+ files
- `.venv/` or `venv/` - Python virtual environments  
- `.git/` - Git repository data
- `__pycache__/` - Python bytecode cache
- `dist/`, `build/` - Build outputs
- `.pytest_cache/` - Test cache

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-07-31 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_